<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Gameon chat tool</title>

    <!-- Friendly, approachable fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@500;700&family=Inter:wght@400;600&display=swap" rel="stylesheet" />

    <style>
      :root {
        /* Purple, cozy + neon hints */
        --bg-0: #0b0714;
        --bg-1: #120c20;
        --primary: #7e3af2;
        /* main purple */
        --primary-2: #a78bfa;
        /* soft lilac */
        --primary-3: #c4b5fd;
        /* lighter for text accents */
        --accent: #00d9ff;
        /* tiny neon hint */
        --glow: 0 0 24px rgba(126, 58, 242, 0.4), 0 0 64px rgba(0, 217, 255, 0.15);
        --card-glass: rgba(255, 255, 255, 0.06);
        /* --card-stroke: rgba(168, 85, 247, .35); */
        /* --card-stroke: #01d0ff2d; */
        --muted: #b6a9d9;
        --text: #e9e6ff;
        --text-dim: #cfc8f5;

        --radius: 14px;
        --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.35);
        --shadow-hard: 0 10px 50px rgba(126, 58, 242, 0.25);

        --bubble-user: linear-gradient(135deg, #3b1e84, #7e3af2);
        /* --bubble-assistant: linear-gradient(135deg, #1a1530, #4c2fae); */
        --bubble-assistant: rgba(255, 255, 255, 0.06);
        --bubble-system: rgba(255, 255, 255, 0.06);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        padding: 22px;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        color: var(--text);
        /* background:
        radial-gradient(600px 400px at 10% -10%, rgba(126, 58, 242, .35), transparent 60%),
        radial-gradient(600px 400px at 100% 0%, rgba(0, 217, 255, .18), transparent 55%),
        linear-gradient(180deg, var(--bg-0), var(--bg-1) 60%, #0f0b1b); */
        background: black;
        position: relative;
        overflow-x: hidden;
      }

      /* Subtle animated stars */
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        z-index: -1;
        background-image: radial-gradient(2px 2px at 20% 30%, rgba(255, 255, 255, 0.35) 50%, transparent 51%), radial-gradient(1.5px 1.5px at 70% 20%, rgba(255, 255, 255, 0.25) 50%, transparent 51%), radial-gradient(1.5px 1.5px at 40% 70%, rgba(255, 255, 255, 0.2) 50%, transparent 51%);
        animation: twinkle 8s linear infinite;
        opacity: 0.5;
      }

      @keyframes twinkle {
        0% {
          transform: translateY(0);
          opacity: 0.5;
        }

        50% {
          opacity: 0.8;
        }

        100% {
          transform: translateY(8px);
          opacity: 0.5;
        }
      }

      /* HUD ‚Äì gamified header */
      .hud {
        max-width: 1200px;
        margin: 0 auto 16px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: center;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 14px;
        border-radius: var(--radius);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
        border: 1px solid var(--card-stroke);
        box-shadow: var(--shadow-soft);
      }

      /* .brand .logo{
        width:14px; height:14px; border-radius:10px;
        background: radial-gradient(60% 60% at 50% 40%, var(--accent), transparent 60%), var(--primary);
        box-shadow: var(--glow);
      } */
      .brand h1 {
        margin: 0;
        font-family: "Chakra Petch", Inter, sans-serif;
        letter-spacing: 0.5px;
        font-size: 18px;
        font-weight: 700;
      }

      .brand span {
        color: var(--primary-3);
        font-weight: 600;
      }

      .xp {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 14px;
        border-radius: var(--radius);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
        border: 1px solid var(--card-stroke);
      }

      .xp .bar {
        position: relative;
        width: 220px;
        height: 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        overflow: hidden;
      }

      .xp .bar::after {
        content: "";
        position: absolute;
        inset: 0;
        width: 62%;
        /* fake progress */
        background: linear-gradient(90deg, var(--primary), var(--accent));
        box-shadow: var(--glow);
      }

      .xp .level {
        font-family: "Chakra Petch", Inter, sans-serif;
        font-weight: 700;
        letter-spacing: 0.5px;
        color: var(--primary-3);
      }

      /* Achievements chips */
      .chips {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .chip {
        font-size: 12px;
        color: var(--text-dim);
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(6px);
      }

      /* Layout */
      .layout {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        /* max-width:1200px; */
        max-width: auto;
        margin: 0 0;
      }

      /* Cards */
      .chat,
      .card {
        /* background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(255, 255, 255, .03)); */
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid var(--card-stroke);
        border-radius: var(--radius);
        padding: 16px;
        box-shadow: var(--shadow-soft);
        backdrop-filter: blur(8px);
      }

      /* Chat column */
      .chat {
        flex: 1;
      }

      .leftCol .chat {
        background: black;
      }

      .chat h2 {
        margin: 0 0 10px;
        font-family: "Chakra Petch", Inter, sans-serif;
        font-weight: 700;
        letter-spacing: 0.4px;
      }

      .messages {
        height: 520px;
        overflow: auto;
        /* border: 1px dashed rgba(167, 139, 250, .35); */
        /* border-radius: 12px; */
        padding: 14px;
        /* background:
        radial-gradient(180px 120px at 15% 10%, rgba(126, 58, 242, .18), transparent 60%),
        linear-gradient(180deg, rgba(255, 255, 255, .04), rgba(255, 255, 255, .02)); */
        /* box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .03); */
        background: black;
      }

      .messages::-webkit-scrollbar {
        width: 8px; /* vertical scrollbar width */
        height: 28px; /* horizontal scrollbar height */
      }

      .bubble {
        display: inline-block;
        margin: 10px 0;
        padding: 12px 14px;
        border-radius: 14px;
        max-width: 82%;
        position: relative;
        /* box-shadow: var(--shadow-hard); */
      }

      .bubble.user {
        background: var(--bubble-user);
        color: #fff;
        align-self: flex-end;
        margin-left: auto;
      }

      .bubble.assistant {
        background: var(--bubble-assistant);
        color: #eae7ff;
        align-self: flex-start;
        margin-right: auto;
      }

      .bubble.system {
        background: var(--bubble-system);
        color: var(--text-dim);
        font-size: 14px;
        /* border: 1px solid rgba(255, 255, 255, .08); */
      }

      .row {
        display: flex;
        gap: 10px;
        margin-top: 14px;
        align-items: stretch;
      }

      textarea {
        flex: 1;
        padding: 12px 14px;
        min-height: 64px;
        resize: vertical;
        color: var(--text);
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        outline: none;
        transition: box-shadow 0.2s, border-color 0.2s, transform 0.08s;
        overflow: hidden; /* hides the scrollbar */
        resize: none; /* optional: disable manual resize */
      }

      textarea:focus {
        border-color: var(--primary-2);
        box-shadow: var(--glow);
      }

      button {
        padding: 12px 16px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: radial-gradient(100% 100% at 50% 0%, rgba(0, 217, 255, 0.22), transparent 51%), linear-gradient(180deg, var(--primary), #5b2bd6);
        color: #fff;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.3px;
        font-family: "Chakra Petch", Inter, sans-serif;
        box-shadow: var(--shadow-hard);
        transition: transform 0.06s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }

      button:hover {
        filter: brightness(1.06);
        box-shadow: 0 0 16px rgba(126, 58, 242, 0.5);
      }

      button:active {
        transform: translateY(1px) scale(0.99);
      }

      .status {
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
      }

      /* Side panel */
      .side {
        flex: 2;
        display: flex;
        flex-direction: column;
        gap: 16px;
        position: sticky;
        top: 20px;
      }

      .card h3 {
        margin: 0 0 10px;
        font-size: 15px;
        letter-spacing: 0.3px;
        font-family: "Chakra Petch", Inter, sans-serif;
        color: var(--primary-3);
      }

      .side textarea {
        min-height: 120px;
      }

      .btns {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        flex-direction: column;
        align-items: start;
      }

      #theCode {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        line-height: 1.5;
        white-space: pre-wrap;
        word-break: break-word;
        background: rgba(10, 8, 20, 0.7);
        border: 1px solid rgba(167, 139, 250, 0.3);
        border-radius: 10px;
        padding: 10px;
        max-height: 260px;
        overflow: auto;
        color: #d8d5ff;
      }

      /* Pretty code output panel */
      #output {
        font-family: Consolas, "Courier New", monospace;
        background: #0d0b16;
        color: #dcd8ff;
        padding: 16px;
        border-radius: 12px;
        white-space: pre;
        overflow-x: auto;
        border: 1px solid rgba(167, 139, 250, 0.3);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      }

      /* light syntax accents */
      #output .k {
        color: #a78bfa;
      }

      /* keywords */
      #output .s {
        color: #7dd3fc;
      }

      /* strings */
      #output .c {
        color: #9aa2b1;
      }

      /* comments */

      /* Iframe preview gets the glass frame */
      .preview {
        width: 100%;
        height: 520px;
        border: 0px;
        border-radius: 12px;
        /* background:
        linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      box-shadow: var(--shadow-soft); */
      }

      #openInNewTab {
        margin-top: 10px;
      }

      /* Responsive */
      @media (max-width: 1100px) {
        .hud {
          grid-template-columns: 1fr;
          gap: 10px;
        }

        .xp {
          justify-content: space-between;
        }
      }

      @media (max-width: 900px) {
        .layout {
          flex-direction: column;
        }

        .side {
          position: static;
        }

        .preview {
          height: 520px;
        }
      }

      /* Tiny helper: badge-like h2 */
      .chat h2::after {
        content: " ‚Ä¢ Beginner Friendly";
        font-size: 12px;
        margin-left: 8px;
        padding: 4px 8px;
        border-radius: 999px;
        color: #2a194c;
        background: #c4b5fd;
      }

      .logo img {
        width: 220px;
        height: 120px;
        object-fit: contain;
        border-radius: 8px;
        /* optional if you want rounded edges */
      }

      .tagline {
        font-family: "Chakra Petch", Inter, sans-serif;
        font-weight: 700;
        letter-spacing: 0.4px;
      }

      .container {
        display: flex;
        flex-direction: row;
      }

      .leftCol {
        display: flex;
        flex-direction: column;
        width: 40%;
      }

      .rightCol {
        display: flex;
        flex-direction: column;
        width: 100%;
        margin-left: 10px;
      }

      .LogoImage {
        width: 140px;
        /* height: 30px; */
        height: auto;
      }

      .logoBundle {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: left;

        position: absolute;
        left: 0px;
        top: 0px;
        z-index: 999;
        width: 70px;
        height: 70px;

        background: rgb(0, 0, 0);
        height: 50px;
        width: 100%;
      }

      .LogoGif {
        width: 50%;
        height: 80%;
      }

      .TextAndTagline {
        display: flex;
        flex-direction: column;
      }

      .fullscreenlogo {
        width: 20px;
        height: 20px;
        filter: brightness(0) invert(1);
      }

      .renderpreview_fullscreen {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
      }

      .LogoGif2 {
        width: 50px;
        /* height: 30px; */
        height: auto;
      }

      /* .interFont{
      font-family: 
    } */

      .font-wrap {
      }

      /* Loader container */
      #loadingLogo {
        display: none;
        margin-top: 8px;
        text-align: center;
      }

      #loadingLogo img {
        width: 300px;
        height: 300px;
        animation: spin 1.4s linear infinite;
        /* border-radius: 100%; */
        /* clip-path: circle(50% at 50% 50%); */

        /*object-fit: cover; /* keeps aspect ratio */
        clip-path: circle(22% at 50% 50%);
      }

      /* #downloadfolder,
      #extractfolder,
      #saveIndexHTML,
      #saveServerjs,
      #gameuser1,
      #gameuser2,
      #startServer,
      #delete {
        display: none;
      } */

      #ui_input {
        display: none;
      }
      @keyframes spin {
        0%,
        100% {
          transform: scale(1);
        }
        /* 25% { */
        /* transform:scale(1.1); */
        /* } */
        50% {
          transform: scale(1.1);
        }
        /* 75% { */
        /* transform:scale(1.3); */
        /* } */
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div class="leftCol">
        <!-- <div class="logoBundle">
        <img src="/gif" class="LogoGif" />
        <div class="TextAndTagline">
          <img src="/logo" class="LogoImage" />
          <div>No coding skills? No problem. Create games anyway.</div>
        </div>
      </div> -->

        <div class="chat">
          <div class="logoBundle">
            <img src="/gif" class="LogoGif2" />
            <img src="/logo" class="LogoImage" />
          </div>
          <!-- <h2>Chat demo ‚Äî (client shows message context)</h2> -->

          <div id="messages" class="messages"></div>

          <div class="row">
            <textarea id="input" placeholder="Type your game logic"></textarea>
            <textarea id="ui_input" placeholder="Type your UI idea"></textarea>
            <button id="sendBtn">Send</button>
          </div>

          <div class="status" id="status">Ready</div>
        </div>
      </div>
      <div class="rightCol">
        <!-- <img src="/logo" width="220px" height="100px" /> -->
        <div class="card">
          <div class="renderpreview_fullscreen">
            <div>
              <h3>Render preview</h3>
              <div id="loadingLogo">
                <img src="/gif" alt="Loading..." />
              </div>
            </div>

            <div>
              <img class="fullscreenlogo" id="fullscreenlogo" src="/fullscreenlogo" />
            </div>
          </div>

          <iframe id="preview" class="preview" sandbox="allow-modals allow-scripts allow-forms allow-pointer-lock allow-popups"></iframe>

          <!-- <button id="openInNewTab">Open preview in new tab</button> -->
        </div>
      </div>
    </div>

    <div class="layout">
      <!-- RIGHT: Adjacent side panel -->
      <aside class="side">
        <div class="card">
          <h3>Actions</h3>
          <div class="btns">
            <!-- <a id="delete" href="https://aiapp.gameonworld.ai/delete">
              <button onclick="this.style.display='none'">Delete folder</button>
            </a> -->
            <br />
            <a id="downloadfolder" href="https://aiapp.gameonworld.ai/server-download" download>
              <button onclick="this.style.display='none'">Download Folder. Note: After game comes, click "Extract folder"</button>
            </a>

            <div>Now send a game idea in the Input box named as "Type your game logic".</div>

            <div>After game comes, click "Save logicofgame.js"</div>
            <div>After game comes, click "Save server.js"</div>

            <a id="extractfolder" onclick="this.style.display='none'" href="https://aiapp.gameonworld.ai/extract" download>
              <button>Extract Folder</button>
            </a>
            <!-- <button id="saveBtn">Save Communication</button> -->
            <!-- <button id="saveIndexHTML">Save Index.html</button> -->
            <button id="savelogicofgamejs">Save logicofgame.js</button>
            <button id="saveServerjs">Save server.js</button>
            <div>Now send a UI idea in the Input box named as "Type your UI idea".</div>

            <div>After result comes, click "Save App.jsx"</div>
            <button id="saveAppjsx">Save App.jsx</button>
            <button id="startServer">Start Game</button>
            <button id="get2links">get 2 links</button>

            <a id="player1Link" href="#" target="_blank"><button>Game link for Player 1</button></a>

            <a id="player2Link" href="#" target="_blank"><button>Game link for Player 2</button></a>

            <!-- <button id="startServer2">Start Game2</button> -->
            <!-- <a
              id="gameuser1"
              href="http://localhost:3000"
              target="_blank"
              download
            >
              <button>Game for Player 1</button>
            </a>
            <a
              id="gameuser2"
              href="http://localhost:3000"
              target="_blank"
              download
            >
              <button>Game for Player 2</button>
            </a> -->
          </div>
        </div>

        <div class="card">
          <h3>Code</h3>
          <pre id="output"></pre>
        </div>

        <div class="card">
          <h3>META Context</h3>
          <textarea id="metainput" placeholder="Type your META CONTEXT"></textarea>
        </div>
      </aside>
    </div>

    <script>
      // Simple client to keep message context and send to chat.php
      const messagesEl = document.getElementById("messages");
      const inputEl = document.getElementById("input");
      const sendBtn = document.getElementById("sendBtn");
      const statusEl = document.getElementById("status");
      const metainputEl = document.getElementById("metainput");
      const saveChat = document.getElementById("saveBtn");
      const saveIndexHTML = document.getElementById("saveIndexHTML");
      const saveAppjsx = document.getElementById("saveAppjsx");
      const saveServerjs = document.getElementById("saveServerjs");
      const startServer = document.getElementById("startServer");
      const startServer2 = document.getElementById("startServer2");
      const theCode = document.getElementById("gameuser1");
      const theCode2 = document.getElementById("gameuser2");
      const savelogicofgamejs = document.getElementById("savelogicofgamejs");
      const get2links = document.getElementById("get2links");

      const ui_input = document.getElementById("ui_input");

      if (saveChat) {
        saveChat.addEventListener("click", () => {
          downloadCommunication(communication); // if you want to save on click
        });
      }

      let latestAssistantMessage = "";

      // initial context: system role (the "priming" described in the video)

      let gameNeeded = "car racing game";
      let logicofgamecode = `
            // logicofgame.js

      export class GameManager {
        constructor(broadcastCallback) {
          // Rooms and broadcast are managed externally (server)
          this.rooms = new Map();
          this.broadcast = broadcastCallback; // function(room, message)
        }

        // --- Initial State ---
        static INITIAL_SNAKES = [
          {
            id: 1,
            name: "Player 1",
            body: [{ x: 5, y: 5 }],
            dir: { x: 1, y: 0 },
            score: 0,
          },
          {
            id: 2,
            name: "Player 2",
            body: [{ x: 15, y: 15 }],
            dir: { x: -1, y: 0 },
            score: 0,
          },
        ];

        // --- Utility methods ---
        generateFoodPosition(grid, snakes) {
          const occupied = new Set();
          for (const snake of snakes) {
            for (const seg of snake.body) {
              occupied.add(\`\${seg.x},\${seg.y}\`);
            }
          }
          let x, y;
          do {
            x = Math.floor(Math.random() * grid);
            y = Math.floor(Math.random() * grid);
          } while (occupied.has(\`\${x},\${y}\`));
          return { x, y };
        }

        createGameState() {
          const grid = 20;
          const snakes = GameManager.INITIAL_SNAKES.map((snake) => ({
            ...snake,
            body: [{ ...snake.body[0] }],
            dir: { ...snake.dir },
          }));
          return {
            grid,
            snakes,
            food: this.generateFoodPosition(grid, snakes),
            timer: 60,
            countdown: 3,
          };
        }

        getWinner(state) {
          const [p1, p2] = state.snakes;
          if (p1.score > p2.score) return \`\${p1.name} wins with \${p1.score} points!\`;
          if (p2.score > p1.score) return \`\${p2.name} wins with \${p2.score} points!\`;
          return \`It's a tie! Both players have \${p1.score} points.\`;
        }

        updateGameState(state) {
          const newHeads = state.snakes.map((snake) => ({
            id: snake.id,
            head: {
              x: snake.body[0].x + snake.dir.x,
              y: snake.body[0].y + snake.dir.y,
            },
          }));

          // --- Head collision ---
          if (
            newHeads.length === 2 &&
            newHeads[0].head.x === newHeads[1].head.x &&
            newHeads[0].head.y === newHeads[1].head.y
          ) {
            state.snakes.forEach((snake) => {
              const initial = GameManager.INITIAL_SNAKES.find(
                (s) => s.id === snake.id
              );
              snake.body = [{ x: initial.body[0].x, y: initial.body[0].y }];
              snake.dir = { ...initial.dir };
            });
            return;
          }

          // --- Regular movement ---
          for (const snake of state.snakes) {
            const head = { ...snake.body[0] };
            head.x = (head.x + snake.dir.x + state.grid) % state.grid;
            head.y = (head.y + snake.dir.y + state.grid) % state.grid;
            snake.body.unshift(head);

            // Eat food
            if (head.x === state.food.x && head.y === state.food.y) {
              snake.score++;
              state.food = this.generateFoodPosition(state.grid, state.snakes);
            } else {
              snake.body.pop();
            }

            // Bite another snake
            for (const other of state.snakes) {
              if (other.id === snake.id) continue;
              for (const seg of other.body) {
                if (head.x === seg.x && head.y === seg.y) {
                  other.score++;
                  snake.score = 0;
                  const initial1 = GameManager.INITIAL_SNAKES.find(
                    (s) => s.id === snake.id
                  );
                  const initial2 = GameManager.INITIAL_SNAKES.find(
                    (s) => s.id === other.id
                  );
                  snake.body = [{ ...initial1.body[0] }];
                  snake.dir = { ...initial1.dir };
                  other.body = [{ ...initial2.body[0] }];
                  other.dir = { ...initial2.dir };
                  return;
                }
              }
            }
          }
        }

        // --- Room / Game Flow Management ---
        createRoom(gameSessionUuid) {
          this.rooms.set(gameSessionUuid, {
            players: new Map(),
            state: this.createGameState(),
          });
          return this.rooms.get(gameSessionUuid);
        }

        addPlayer(gameSessionUuid, playerUuid, ws) {
          if (!this.rooms.has(gameSessionUuid)) {
            this.createRoom(gameSessionUuid);
          }
          const room = this.rooms.get(gameSessionUuid);
          room.players.set(playerUuid, ws);
          return room;
        }

        removePlayer(gameSessionUuid, playerUuid) {
          const room = this.rooms.get(gameSessionUuid);
          if (!room) return;
          room.players.delete(playerUuid);
          if (room.players.size === 0) {
            this.rooms.delete(gameSessionUuid);
          }
        }

        startCountdown(room) {
          const interval = setInterval(() => {
            room.state.countdown = Math.max(0, room.state.countdown - 1);
            this.broadcast(room, { type: "state", data: room.state });

            if (room.state.countdown <= 0) {
              clearInterval(interval);
              this.startGameLoop(room);
            }
            if (room.players.size < 2) {
              clearInterval(interval);
              this.broadcast(room, { type: "gameStopped" });
            }
          }, 1000);
        }

        startGameLoop(room) {
          const interval = setInterval(() => {
            this.updateGameState(room.state);
            this.broadcast(room, { type: "state", data: room.state });
            room.state.timer = Math.max(0, room.state.timer - 0.2);

            if (room.state.timer <= 0 || room.players.size < 2) {
              clearInterval(interval);
              const result = this.getWinner(room.state);
              this.broadcast(room, { type: "gameOver", message: result });
              this.broadcast(room, { type: "gameStopped" });
            }
          }, 200);
        }
      }

            `;
      let servercode = `
      import express from "express";
      import http from "http";
      import { WebSocketServer } from "ws";
      import cors from "cors";
      import dotenv from "dotenv";
      import path from "path";
      import Room from "./schemas/roomSchema.js";
      import { fileURLToPath } from "url";
      import { v4 as uuidv4 } from "uuid";
      // import { GameManager } from "./gamelogic.js";
      import { GameManager } from "./logicofgame.js";

      dotenv.config();

      const __filename = fileURLToPath(import.meta.url);
      const __dirname = path.dirname(__filename);

      const app = express();
      const server = http.createServer(app);
      const ws = new WebSocketServer({ server });
      const PORT = process.env.GAME_PORT || 8087;
      // const gameManager = new GameManager(ws);
      app.use(cors());
      app.use(express.json());
      // app.use(express.static(path.join(__dirname, "../frontend")));

      const rooms = new Map();

      function broadcast(room, message) {
        const json = JSON.stringify(message);
        for (const [, playerWs] of room.players) {
          if (playerWs.readyState === 1) playerWs.send(json);
        }
      }

      const gameManager = new GameManager(broadcast);

      app.post("/api/createRoom", async (req, res) => {
        try {
          const { room, players } = req.body;
          const id = uuidv4();

          // Create a new Room model instance
          const newRoom = new Room({
            gameSessionUuid: room?.gameSessionUuid || id,
            name: room?.name || \`Snake Room \${id.slice(0, 4)}\`,
            players: players || [],
          });

          // Save to database
          // await newRoom.save();

          // Create a new game instance
          // const game = gameManager.createGame(newRoom.gameSessionUuid);

          const frontend = process.env.FRONTEND_URL;
          const link1 = \`\${frontend}/?gameSessionUuid=\${
            newRoom.gameSessionUuid
          }&gameStateId=\${newRoom._id}&uuid=\${players?.[0]?.uuid || ""}\`;
          const link2 = \`\${frontend}/?gameSessionUuid=\${
            newRoom.gameSessionUuid
          }&gameStateId=\${newRoom._id}&uuid=\${players?.[1]?.uuid || ""}\`;
          return res.json({
            status: true,
            message: "success",
            payload: {
              gameSessionUuid: newRoom.gameSessionUuid,
              gameStateId: newRoom._id,
              name: newRoom.name,
              createDate: newRoom.createdDate,
              link1,
              link2,
            },
          });
        } catch (err) {
          console.error("createRoom error", err);
          return res.status(500).json({ status: false, message: "Server error" });
        }
      });

      // --- WebSocket Events ---
      ws.on("connection", (ws) => {
        ws.on("message", (msg) => {
          try {
            const data = JSON.parse(msg);

            switch (data.type) {
              case "joinGame": {
                const { gameSessionUuid, playerUuid } = data;
                const room = gameManager.addPlayer(gameSessionUuid, playerUuid, ws);
                ws.roomId = gameSessionUuid;
                ws.playerUuid = playerUuid;

                const playerNum = room.players.size + 1;
                ws.send(
                  JSON.stringify({
                    type: "joined",
                    role: "player",
                    playerNum,
                    data: room.state,
                  })
                );
                if (room.players.size === 2) {
                  broadcast(room, { type: "gameStarted" });
                  gameManager.startCountdown(room);
                }
                break;
              }
              case "dir": {
                const room = gameManager.rooms.get(ws.roomId);
                if (!room) return;
                const snakeIndex = [...room.players.keys()].indexOf(ws.playerUuid);
                const snake = room.state.snakes[snakeIndex];
                const newDir = data.data;
                if (
                  newDir &&
                  !(newDir.x === -snake.dir.x && newDir.y === -snake.dir.y)
                ) {
                  snake.dir = newDir;
                }
                break;
              }
            }
          } catch (err) {
            console.error("Message error:", err);
            ws.send(JSON.stringify({ type: "error", message: "Invalid message" }));
          }
        });

        ws.on("close", () => {
          if (ws.roomId && rooms.has(ws.roomId)) {
            const room = rooms.get(ws.roomId);
            room.players.delete(ws.playerUuid);
            if (room.players.size === 0) {
              rooms.delete(ws.roomId);
            } else {
              broadcast(room, { type: "gameStopped" });
            }
          }
        });
      });

      // --- Start Server ---
      server.listen(PORT, () => {
        console.log(\`‚úÖ WebSocket server running on http://localhost:\${PORT}\`);
      });

      `;
      let appjsxcode = `
      import React, { useEffect, useRef, useState } from "react";
import eatSoundFile from "../public/sounds/eat.mp3";
import hissSoundFile from "../public/sounds/hiss.mp3";
import "./App.css";

export default function App() {
  const canvasRef = useRef(null);
  const [log, setLog] = useState([]);
  const wsRef = useRef(null);
  const prevStateRef = useRef({
    snakes: [{ score: 0 }, { score: 0 }],
    food: { x: -1, y: -1 },
  });

  const appendLog = (msg) => setLog((prev) => [...prev, msg]);

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const gameSessionUuid = urlParams.get("gameSessionUuid");
    const playerUuid = urlParams.get("uuid");

    const ws = new WebSocket(\`wss://aigameb.gameonworld.ai/socket\`);
    wsRef.current = ws;

    const eatSound = new Audio(eatSoundFile);
    const hissSound = new Audio(hissSoundFile);

    ws.addEventListener("open", () => {
      appendLog("‚úÖ Connected to WebSocket server");
      if (gameSessionUuid && playerUuid) {
        ws.send(
          JSON.stringify({
            type: "joinGame",
            gameSessionUuid,
            playerUuid,
          })
        );
      }
    });

    ws.addEventListener("message", (event) => {
      try {
        const msg = JSON.parse(event.data);
        switch (msg.type) {
          case "joined":
            appendLog(\`Joined as \${msg.role} (\${msg.playerNum || "spectator"})\`);
            break;
          case "state":
            handleState(msg.data, eatSound, hissSound);
            break;
          case "error":
            appendLog(\`‚ùå Error: \${msg.message}\`);
            break;
          case "gameStarted":
            appendLog("üéÆ Game started!");
            break;
          case "gameStopped":
            appendLog("üõë Game stopped!");
            break;
          case "gameOver":
            appendLog(\`üèÜ \${msg.message}\`);
            drawGameOver(msg.message);
            break;
          default:
            console.log("Unknown message:", msg);
        }
      } catch (e) {
        console.error("Bad message:", e);
      }
    });

    ws.addEventListener("close", () => appendLog("‚ö†Ô∏è Disconnected"));

    const ctx = canvasRef.current.getContext("2d");
    const resize = () => {
      const s = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.7, 720);
      canvasRef.current.width = Math.floor(s);
      canvasRef.current.height = Math.floor(s);
    };
    resize();
    window.addEventListener("resize", resize);

    function handleState(state, eatSound, hissSound) {
      const prevState = prevStateRef.current;
      if (state.snakes && Array.isArray(state.snakes)) {
        state.snakes.forEach((snake, index) => {
          if (!snake || !snake.body || snake.body.length === 0) return;
          if (!prevState.snakes || !prevState.snakes[index]) return;

          if (snake.score > prevState.snakes[index].score) {
            const head = snake.body[0];
            if (head.x === prevState.food.x && head.y === prevState.food.y) {
              eatSound.play().catch(console.error);
            } else {
              let isBite = false;
              for (const other of state.snakes) {
                if (other.id !== snake.id && other.body) {
                  for (const seg of other.body) {
                    if (head.x === seg.x && head.y === seg.y) {
                      isBite = true;
                      break;
                    }
                  }
                  if (isBite) break;
                }
              }
              if (isBite) hissSound.play().catch(console.error);
            }
          }
        });
        prevStateRef.current = {
          snakes: state.snakes.map((s) => ({
            score: s?.score || 0,
            body: s?.body || [],
          })),
          food: { ...(state.food || { x: -1, y: -1 }) },
        };
      }
      draw(ctx, state);
    }

    function draw(ctx, state) {
      if (!state) return;
      const grid = state.grid || 20;
      const cell = canvasRef.current.width / grid;
      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);

      ctx.fillStyle = "#22c55e";
      for (const s of state.snakes || []) {
        if (!s.body || s.body.length === 0) continue;
        for (const seg of s.body) {
          ctx.fillRect(seg.x * cell, seg.y * cell, cell - 2, cell - 2);
        }
        if (s.name && s.body[0]) {
          const head = s.body[0];
          ctx.fillStyle = "#ffffff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.name, head.x * cell + cell / 2, head.y * cell + cell / 2);
        }
      }

      if (state.food) {
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(state.food.x * cell, state.food.y * cell, cell - 2, cell - 2);
      }

      ctx.fillStyle = "#ffffff";
      ctx.font = "16px Arial";
      ctx.textAlign = "left";
      if (state.snakes && state.snakes[0]) ctx.fillText(\`\${state.snakes[0].name}: \${state.snakes[0].score}\`, 10, 10);
      ctx.textAlign = "right";
      if (state.snakes && state.snakes[1]) ctx.fillText(\`\${state.snakes[1].name}: \${state.snakes[1].score}\`, canvasRef.current.width - 10, 10);

      ctx.textAlign = "center";
      if (state.countdown > 0) {
        ctx.font = "48px Arial";
        ctx.fillText(Math.ceil(state.countdown).toString(), canvasRef.current.width / 2, canvasRef.current.height / 2);
      } else {
        ctx.fillText(\`Time: \${Math.ceil(state.timer)}s\`, canvasRef.current.width / 2, 10);
      }
    }

    function drawGameOver(message) {
      const ctx = canvasRef.current.getContext("2d");
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      ctx.fillStyle = "#ffffff";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Game Over", canvasRef.current.width / 2, canvasRef.current.height / 2 - 20);
      ctx.fillText(message, canvasRef.current.width / 2, canvasRef.current.height / 2 + 20);
    }

    return () => {
      ws.close();
      window.removeEventListener("resize", resize);
    };
  }, []);

  // controls
  const sendDir = (dir) => {
    wsRef.current?.send(JSON.stringify({ type: "dir", data: dir }));
  };

  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: "10px",
        padding: "14px",
        background: "#0b1020",
        minHeight: "100vh",
        color: "#e5e7eb",
      }}
    >
      <canvas
        ref={canvasRef}
        style={{
          background: "#0f172a",
          border: "1px solid #1f2937",
          width: "min(90vmin, 720px)",
          height: "min(90vmin, 720px)",
          imageRendering: "pixelated",
        }}
      />
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(3, 60px)",
          gridTemplateRows: "repeat(2, 60px)",
          gap: "5px",
        }}
      >
        <button className="control-btn" id="up-btn" style={{ gridColumn: 2, gridRow: 1 }} onClick={() => sendDir({ x: 0, y: -1 })}>
          ‚Üë
        </button>
        <button className="control-btn" id="left-btn" style={{ gridColumn: 1, gridRow: 2 }} onClick={() => sendDir({ x: -1, y: 0 })}>
          ‚Üê
        </button>
        <button className="control-btn" id="right-btn" style={{ gridColumn: 3, gridRow: 2 }} onClick={() => sendDir({ x: 1, y: 0 })}>
          ‚Üí
        </button>
        <button className="control-btn" id="down-btn" style={{ gridColumn: 2, gridRow: 2 }} onClick={() => sendDir({ x: 0, y: 1 })}>
          ‚Üì
        </button>
      </div>

      <div id="log" style={{ fontSize: "14px", marginTop: "10px", textAlign: "center" }}>
        {log.map((l, i) => (
          <div key={i}>{l}</div>
        ))}
      </div>
    </div>
  );
}
      `;
      let appjsxcodeWithoutSounds = `
      import React, { useEffect, useRef, useState } from "react";
import "./App.css";

export default function App() {
  const canvasRef = useRef(null);
  const [log, setLog] = useState([]);
  const wsRef = useRef(null);
  const prevStateRef = useRef({
    snakes: [{ score: 0 }, { score: 0 }],
    food: { x: -1, y: -1 },
  });

  const appendLog = (msg) => setLog((prev) => [...prev, msg]);

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const gameSessionUuid = urlParams.get("gameSessionUuid");
    const playerUuid = urlParams.get("uuid");

    const ws = new WebSocket(\`wss://aigameb.gameonworld.ai/socket\`);
    wsRef.current = ws;

    ws.addEventListener("open", () => {
      appendLog("‚úÖ Connected to WebSocket server");
      if (gameSessionUuid && playerUuid) {
        ws.send(
          JSON.stringify({
            type: "joinGame",
            gameSessionUuid,
            playerUuid,
          })
        );
      }
    });

    ws.addEventListener("message", (event) => {
      try {
        const msg = JSON.parse(event.data);
        switch (msg.type) {
          case "joined":
            appendLog(\`Joined as \${msg.role} (\${msg.playerNum || "spectator"})\`);
            break;
          case "state":
            handleState(msg.data);
            break;
          case "error":
            appendLog(\`‚ùå Error: \${msg.message}\`);
            break;
          case "gameStarted":
            appendLog("üéÆ Game started!");
            break;
          case "gameStopped":
            appendLog("üõë Game stopped!");
            break;
          case "gameOver":
            appendLog(\`üèÜ \${msg.message}\`);
            drawGameOver(msg.message);
            break;
          default:
            console.log("Unknown message:", msg);
        }
      } catch (e) {
        console.error("Bad message:", e);
      }
    });

    ws.addEventListener("close", () => appendLog("‚ö†Ô∏è Disconnected"));

    const ctx = canvasRef.current.getContext("2d");
    const resize = () => {
      const s = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.7, 720);
      canvasRef.current.width = Math.floor(s);
      canvasRef.current.height = Math.floor(s);
    };
    resize();
    window.addEventListener("resize", resize);

    function handleState(state) {
      const prevState = prevStateRef.current;
      if (state.snakes && Array.isArray(state.snakes)) {
        state.snakes.forEach((snake, index) => {
          if (!snake || !snake.body || snake.body.length === 0) return;
          if (!prevState.snakes || !prevState.snakes[index]) return;

          if (snake.score > prevState.snakes[index].score) {
            const head = snake.body[0];
            if (head.x === prevState.food.x && head.y === prevState.food.y) {
            } else {
              let isBite = false;
              for (const other of state.snakes) {
                if (other.id !== snake.id && other.body) {
                  for (const seg of other.body) {
                    if (head.x === seg.x && head.y === seg.y) {
                      isBite = true;
                      break;
                    }
                  }
                  if (isBite) break;
                }
              }
            }
          }
        });
        prevStateRef.current = {
          snakes: state.snakes.map((s) => ({
            score: s?.score || 0,
            body: s?.body || [],
          })),
          food: { ...(state.food || { x: -1, y: -1 }) },
        };
      }
      draw(ctx, state);
    }

    function draw(ctx, state) {
      if (!state) return;
      const grid = state.grid || 20;
      const cell = canvasRef.current.width / grid;
      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);

      ctx.fillStyle = "#22c55e";
      for (const s of state.snakes || []) {
        if (!s.body || s.body.length === 0) continue;
        for (const seg of s.body) {
          ctx.fillRect(seg.x * cell, seg.y * cell, cell - 2, cell - 2);
        }
        if (s.name && s.body[0]) {
          const head = s.body[0];
          ctx.fillStyle = "#ffffff";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(s.name, head.x * cell + cell / 2, head.y * cell + cell / 2);
        }
      }

      if (state.food) {
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(state.food.x * cell, state.food.y * cell, cell - 2, cell - 2);
      }

      ctx.fillStyle = "#ffffff";
      ctx.font = "16px Arial";
      ctx.textAlign = "left";
      if (state.snakes && state.snakes[0]) ctx.fillText(\`\${state.snakes[0].name}: \${state.snakes[0].score}\`, 10, 10);
      ctx.textAlign = "right";
      if (state.snakes && state.snakes[1]) ctx.fillText(\`\${state.snakes[1].name}: \${state.snakes[1].score}\`, canvasRef.current.width - 10, 10);

      ctx.textAlign = "center";
      if (state.countdown > 0) {
        ctx.font = "48px Arial";
        ctx.fillText(Math.ceil(state.countdown).toString(), canvasRef.current.width / 2, canvasRef.current.height / 2);
      } else {
        ctx.fillText(\`Time: \${Math.ceil(state.timer)}s\`, canvasRef.current.width / 2, 10);
      }
    }

    function drawGameOver(message) {
      const ctx = canvasRef.current.getContext("2d");
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      ctx.fillStyle = "#ffffff";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Game Over", canvasRef.current.width / 2, canvasRef.current.height / 2 - 20);
      ctx.fillText(message, canvasRef.current.width / 2, canvasRef.current.height / 2 + 20);
    }

    return () => {
      ws.close();
      window.removeEventListener("resize", resize);
    };
  }, []);

  // controls
  const sendDir = (dir) => {
    wsRef.current?.send(JSON.stringify({ type: "dir", data: dir }));
  };

  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: "10px",
        padding: "14px",
        background: "#0b1020",
        minHeight: "100vh",
        color: "#e5e7eb",
      }}
    >
      <canvas
        ref={canvasRef}
        style={{
          background: "#0f172a",
          border: "1px solid #1f2937",
          width: "min(90vmin, 720px)",
          height: "min(90vmin, 720px)",
          imageRendering: "pixelated",
        }}
      />
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(3, 60px)",
          gridTemplateRows: "repeat(2, 60px)",
          gap: "5px",
        }}
      >
        <button className="control-btn" id="up-btn" style={{ gridColumn: 2, gridRow: 1 }} onClick={() => sendDir({ x: 0, y: -1 })}>
          ‚Üë
        </button>
        <button className="control-btn" id="left-btn" style={{ gridColumn: 1, gridRow: 2 }} onClick={() => sendDir({ x: -1, y: 0 })}>
          ‚Üê
        </button>
        <button className="control-btn" id="right-btn" style={{ gridColumn: 3, gridRow: 2 }} onClick={() => sendDir({ x: 1, y: 0 })}>
          ‚Üí
        </button>
        <button className="control-btn" id="down-btn" style={{ gridColumn: 2, gridRow: 2 }} onClick={() => sendDir({ x: 0, y: 1 })}>
          ‚Üì
        </button>
      </div>

      <div id="log" style={{ fontSize: "14px", marginTop: "10px", textAlign: "center" }}>
        {log.map((l, i) => (
          <div key={i}>{l}</div>
        ))}
      </div>
    </div>
  );
}
`;

      let communication = [
        {
          role: "system",
          content:
            "You are a helpful assistant that generate game codes. I have never coded in my life. " +
            "Change the logic of below codes logicofgame.js and server.js to a needed game" +
            //below "make sure to..." is experimental yet
            "make sure to keep the classname GameManager the same. adjust the input used to control too" +
            ". Give me the output in the format ## logicofgame.js and ## server.js." +
            "The codes to convert are: " +
            "\n\n## logicofgame.js\n\n" +
            logicofgamecode +
            "\n\n## server.js\n\n" +
            servercode +
            "## needed game is below",
        },

        // This is for babylon js (with sockets)
        //    Craft later

        // {
        //   role: "system",
        //   content: `You are a helpful assistant`
        // },
      ];

      console.log(communication);
      // render all messages from 'communication' to the UI

      function renderMessages() {
        messagesEl.innerHTML = "";
        // Each message becomes a bubble
        const withoutFirst = communication.slice(1);

        withoutFirst.forEach((msg) => {
          const div = document.createElement("div");
          div.classList.add("bubble");
          if (msg.role === "user") div.classList.add("user");
          else if (msg.role === "assistant") div.classList.add("assistant");
          else if (msg.role === "System") div.classList.add("system");
          div.innerHTML = `<strong"><b>${msg.role}</b></strong><div>${escapeHtml(msg.content)}</div>`;
          messagesEl.appendChild(div);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function escapeHtml(text) {
        if (!text) return "";
        return text.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;").replaceAll("\n", "<br/>");
      }

      async function downloadCommunication(comm) {
        const text = JSON.stringify(comm, null, 2);
        const blob = new Blob([text], { type: "text/plain" });

        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: "Game chat-.txt",
            types: [
              {
                description: "Text Files",
                accept: { "text/plain": [".txt"] },
              },
            ],
          });

          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();
          console.log("File saved!");
        } catch (err) {
          console.error("Save cancelled or failed:", err);
        }
      }

      const loadingLogo = document.getElementById("loadingLogo");

      let firstTime = true;

      let toggleDisplayOfInputBox = false;

      async function sendMessage1() {
        const text = inputEl.value.trim();

        const ui_input_text = ui_input.value.trim();

        const metatext = metainputEl.value.trim();

        let finalText = metatext;

        toggleDisplayOfInputBox = !toggleDisplayOfInputBox;
        if (toggleDisplayOfInputBox) {
          inputEl.style.display = "none";
          ui_input.style.display = "block";
        } else {
          inputEl.style.display = "block";
          ui_input.style.display = "none";
        }

        if (text.length != 0) {
          console.log("We have text");
          finalText = " " + "Update the logic of the game as below" + text;
        } else if (ui_input_text.length != 0) {
          console.log("We don't have text, but we have UI text");
          finalText = " " + "give me the react frontend App.jsx for above codes. give everything in 1 file. give in the format #### App.jsx. Dont wrap in a single HTML. Use this template for App.jsx. The template is: " + appjsxcodeWithoutSounds + ". make below modification. " + ui_input_text;
        } else {
          console.log("We have nothing");
          return;
        }

        // add user's message to communication (transparency like in the video)
        communication.push({ role: "user", content: finalText });
        renderMessages();
        inputEl.value = "";
        ui_input.value = "";
        statusEl.textContent = "Sending...";
        loadingLogo.style.display = "block"; // show loader
        // theCode.style.display = "none";
        // theCode2.style.display = "none";

        sendBtn.disabled = true;

        try {
          // console.log("communication", communication);

          // console.log("Hi")
          // POST the entire messages array to the server
          const resp = await fetch("/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ messages: communication }),
          });

          // console.log("communication", communication);
          // console.log("Hi2")

          if (!resp.ok) {
            const txt = await resp.text();
            statusEl.textContent = "Server error: " + resp.status;
            console.error("Server response:", txt);
            return;
          }

          //print("Hi3")
          const data = await resp.json();

          // The PHP returns the raw API response (or an extracted assistant message).
          // Here we follow the behavior in the video: pick choices[0].message.content
          let assistantMessage = null;
          if (data.choices && data.choices[0] && data.choices[0].message) {
            assistantMessage = data.choices[0].message.content;
          } else if (data.error) {
            assistantMessage = `Error from API: \${data.error}`;
          } else {
            assistantMessage = JSON.stringify(data).slice(0, 1000);
          }

          // add assistant response to communication (so it persists in context)
          communication.push({ role: "assistant", content: assistantMessage });
          renderMessages();
          statusEl.textContent = "Ready";

          latestAssistantMessage = assistantMessage;

          const previewEl = document.getElementById("preview");
          const openBtn = document.getElementById("openInNewTab");
          const fullscreenBtn = document.getElementById("fullscreenlogo");

          const sampleText = assistantMessage;

          (async () => {
            const htmlContent = await extractHtmlFromText(sampleText);
            const serverjscontent = await extractServerjsFromText(sampleText);

            if (htmlContent) {
              // If you want it to render as HTML:

              // document.getElementById("output").innerHTML = " <pre><code> "
              document.getElementById("output").textContent = htmlContent;
              // document.getElementById("output").innerHTML = " </code></pre> "

              // Render the page:
              previewEl.srcdoc = "htmlContent";

              openBtn?.addEventListener("click", () => {
                const html = document.getElementById("output").textContent || "";
                const blob = new Blob([html], { type: "text/html" });
                const url = URL.createObjectURL(blob);
                window.open(url, "_blank");
                // (Optionally) URL.revokeObjectURL(url) later
              });

              fullscreenBtn?.addEventListener("click", () => {
                const html = document.getElementById("output").textContent || "";
                const blob = new Blob([html], { type: "text/html" });
                const url = URL.createObjectURL(blob);
                window.open(url, "_blank");
                // (Optionally) URL.revokeObjectURL(url) later
              });
            }
          })();
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Request failed";
        } finally {
          loadingLogo.style.display = "none"; // hide loader
          sendBtn.disabled = false;

          // theCode.style.display = "block";
          // theCode2.style.display = "block";
        }
      }

      sendBtn.addEventListener("click", sendMessage1);
      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
          // Ctrl+Enter to send
          sendMessage1();
        }
      });

      // initial render (will show the system message)
      renderMessages();

      async function extractHtmlFromText(source) {
        if (!source) return null;

        // Try fenced block: ```html ... ```
        const fenceRegex = /```html\s*\n([\s\S]*?)```/i;
        const fenceMatch = source.match(fenceRegex);
        if (fenceMatch && fenceMatch[1]) {
          return fenceMatch[1].trim();
        }

        // Fallback: from <!DOCTYPE ... to </html>
        const start = source.toLowerCase().indexOf("<!doctype");
        const end = source.toLowerCase().lastIndexOf("</html>");
        if (start !== -1 && end !== -1) {
          return source.slice(start, end + "</html>".length).trim();
        }

        return null;
      }

      async function extractAppJsxFromText(source) {
        if (!source) return null;

        // Match the section that starts with "## App.jsx" and capture code inside the ``` block
        const regex = /##\s*App\.jsx\s*```(?:javascript)?\s*([\s\S]*?)```/i;
        const match = source.match(regex);
        console.log("match", match);
        console.log("match[1].trim()", match[1].trim());
        return match ? match[1].trim() : null;
      }

      async function extractAndSaveHtml(rawText) {
        const html = await extractHtmlFromText(rawText);
        if (!html) return alert("No HTML content found!");

        try {
          const resp = await fetch("/save-html", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ content: html }),
          });
          const data = await resp.json();
          console.log("Saved at:", data.path);
          alert("index.html saved to Downloads!");
        } catch (err) {
          console.error("Save failed:", err);
        }
      }

      async function extractAndSaveAppjsx(rawText) {
        const appjsx = await extractAppJsxFromText(rawText);
        if (!appjsx) return alert("No App.jsx content found!");
        console.log("appjsx", appjsx);
        try {
          const resp = await fetch("/save-appjsx", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ content: appjsx }),
          });
          const data = await resp.json();
          console.log("Saved at:", data.path);
          alert("App.jsx saved to Downloads!");
        } catch (err) {
          console.error("Save failed:", err);
        }
      }

      async function extractServerjsFromText(source) {
        if (!source) return null;

        // Match the section that starts with "## server.js" and capture code inside the ``` block
        const regex = /##\s*server\.js\s*```(?:javascript)?\s*([\s\S]*?)```/i;
        const match = source.match(regex);

        if (match && match[1]) {
          const extracted = match[1].trim();
          console.log("Extracted server.js content:", extracted);
          return extracted;
        } else {
          console.log("server.js content not found");
          return null;
        }
      }

      async function extractAndSaveServerj(rawText) {
        const serverjs = await extractServerjsFromText(rawText);
        if (!serverjs) return alert("No Server.js content found!");

        try {
          const resp = await fetch("/save-serverjs", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ content: serverjs }),
          });
          const data = await resp.json();
          console.log("Saved at:", data.path);
          alert("server.js saved to Downloads!");
        } catch (err) {
          console.error("Save failed:", err);
        }
      }

      async function extractLogicOfGameFromText(source) {
        if (!source) return null;

        // Match the section that starts with "## logicofgame.js" and capture code inside the ``` block
        const regex = /##\s*logicofgame\.js\s*```(?:javascript)?\s*([\s\S]*?)```/i;
        const match = source.match(regex);

        if (match && match[1]) {
          const extracted = match[1].trim();
          console.log("Extracted logicofgame.js content:", extracted);
          return extracted;
        }

        return null;
      }

      async function extractAndSaveLogicOfGame(rawText) {
        const logicofgame = await extractLogicOfGameFromText(rawText);
        // if (!logicofgame) return alert("No logicofgamejs content found!");
        console.log("logicofgame", logicofgame);
        try {
          const resp = await fetch("/save-logicofgamejs", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ content: logicofgame }),
          });
          const data = await resp.json();
          console.log("Saved at:", data.path);
          alert("logicofgame.js saved to Downloads!");
        } catch (err) {
          console.error("Save failed:", err);
        }
      }

      if (saveIndexHTML) {
        saveIndexHTML.addEventListener("click", () => {
          extractAndSaveHtml(latestAssistantMessage);
        });
      }
      if (saveAppjsx) {
        saveAppjsx.addEventListener("click", () => {
          extractAndSaveAppjsx(latestAssistantMessage);
        });
      }

      if (saveServerjs) {
        saveServerjs.addEventListener("click", () => {
          extractAndSaveServerj(latestAssistantMessage);
        });
      }
      if (savelogicofgamejs) {
        savelogicofgamejs.addEventListener("click", () => {
          console.log("clicked savelogicofgamejs");
          extractAndSaveLogicOfGame(latestAssistantMessage);
        });
      }

      const chips = document.querySelectorAll(".chip");
      chips.forEach((chip, i) => {
        chip.animate(
          [
            { filter: "brightness(1)", boxShadow: "none" },
            {
              filter: "brightness(1.2)",
              boxShadow: "0 0 16px rgba(126,58,242,.45)",
            },
            { filter: "brightness(1)", boxShadow: "none" },
          ],
          {
            duration: 1400 + i * 200,
            iterations: 1,
            easing: "ease-in-out",
            delay: 200 + i * 120,
          }
        );
      });
    </script>

    <script>
      async function RunServer(rawText) {
        // const match = rawText.match(/```javascript([\s\S]*?)```/);

        try {
          // 2. Start the file
          const runResp = await fetch("/start-server");
          const runText = await runResp.text();
          alert(runText); // "server.js started in Downloads!"
        } catch (err) {
          console.error("Error:", err);
          alert("Something went wrong while saving or starting server.js");
        }
      }

      if (startServer) {
        startServer.addEventListener("click", () => {
          RunServer(latestAssistantMessage);
          // startServer.style.display = "none";
        });
      }

      async function RunServer2(rawText) {
        // const match = rawText.match(/```javascript([\s\S]*?)```/);

        try {
          // 2. Start the file
          const runResp = await fetch("/start-server2");
          const runText = await runResp.text();
          alert(runText); // "server.js started in Downloads!"
        } catch (err) {
          console.error("Error:", err);
          alert("Something went wrong while saving or starting server.js");
        }
      }

      if (startServer2) {
        startServer2.addEventListener("click", () => {
          RunServer2(latestAssistantMessage);
          // startServer.style.display = "none";
        });
      }

      async function get2Links() {
        try {
          const resp = await fetch("/get2links", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ content: "request" }),
          });
          const data = await resp.json();
          // console.log(data);
          if (data.status && data.payload) {
            const { link1, link2 } = data.payload;

            document.getElementById("player1Link").href = link1;
            document.getElementById("player2Link").href = link2;

            // Optional: display text as the actual link
            // document.getElementById("player1Link").textContent =
            //   "Game for Player 1";
            // document.getElementById("player2Link").textContent =
            //   "Game for Player 2";

            console.log("‚úÖ Links set:", link1, link2);
          } else {
            console.error("Invalid response:", data);
          }
        } catch (err) {
          console.error("no data");
        }
      }

      if (get2links) {
        get2links.addEventListener("click", () => {
          get2Links();
          // startServer.style.display = "none";
        });
      }
    </script>
    <script></script>
  </body>
</html>
